#!/usr/bin/env python3
import subprocess
import sys
import os
import time
import tempfile
import math
import json
import argparse
from enum import Enum
from pathlib import Path

from PIL import Image, ImageOps, ImageChops, ImageFilter
import gi

gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, Gdk, Gio, GLib, Pango, GdkPixbuf, cairo

import numpy as np


class DisplayServer(Enum):
    X11 = "x11"
    WAYLAND = "wayland"
    XWAYLAND = "xwayland"
    UNKNOWN = "unknown"


def is_background_bright(image):
    """Detect if background is brighter than foreground by analyzing histogram distribution"""
    if image.mode != "L":
        image = image.convert("L")

    hist = image.histogram()
    if not hist:
        return False

    # Find min and max non-zero intensity values
    try:
        min_val = next(i for i, count in enumerate(hist) if count > 0)
        max_val = next(i for i in range(len(hist) - 1, -1, -1) if hist[i] > 0)
    except StopIteration:
        return False  # All black pixels? -> pick dark background

    midpoint = (min_val + max_val) // 2

    # If upper half has more pixels, background is likely bright
    n_lower_pixels = sum(hist[min_val : midpoint + 1])
    n_upper_pixels = sum(hist[midpoint + 1 : max_val + 1])
    return n_upper_pixels > n_lower_pixels


def equalize_background(image, radius):
    """Equalize background lighting while preserving text details"""
    if image.mode != "L":
        image = image.convert("L")

    # Check if background is bright and invert if needed
    invert = is_background_bright(image)
    if invert:
        image = ImageOps.invert(image)

    # Apply morphological operations to enhance background
    background = image.filter(ImageFilter.GaussianBlur(radius=radius))

    # Subtract background from original to normalize lighting
    normalized = ImageChops.subtract(image, background)

    # Apply CLAHE effect
    enhanced = normalized.point(lambda x: min(255, x * 1.2))

    # Invert back if we inverted earlier
    if invert:
        enhanced = ImageOps.invert(enhanced)

    return enhanced


def otsu_binarize(image):
    # Convert to grayscale if needed
    if image.mode != "L":
        image = image.convert("L")

    # Get histogram
    hist, bins = np.histogram(np.array(image), 256, [0, 256])
    hist = hist.astype(float)

    # Calculate probabilities
    prob = hist / hist.sum()

    # Calculate cumulative probabilities and means
    cum_prob = np.cumsum(prob)
    cum_mean = np.cumsum(prob * np.arange(256))

    # Calculate between-class variance
    var_between = cum_prob * (cum_mean / cum_prob - cum_mean[-1]) ** 2

    # Find threshold that maximizes variance
    threshold = np.argmax(var_between) if var_between.max() > 0 else 128

    # Apply threshold
    return image.point(lambda x: 255 if x > threshold else 0)


def otsu_binarize_improved(image):
    if image.mode != "L":
        image = image.convert("L")

    # Apply Gaussian blur to reduce noise
    blurred = image.filter(ImageFilter.GaussianBlur(radius=1))

    # Get histogram
    hist, bins = np.histogram(np.array(blurred), 256, [0, 256])
    hist = hist.astype(float)

    # Normalize histogram
    prob = hist / hist.sum()

    # Calculate cumulative probabilities and means
    cum_prob = np.cumsum(prob)
    cum_mean = np.cumsum(prob * np.arange(256))

    # Calculate between-class variance
    var_between = np.zeros(256)
    for i in range(1, 255):
        if cum_prob[i] > 0 and cum_prob[i] < 1:
            var_between[i] = (cum_mean[-1] * cum_prob[i] - cum_mean[i]) ** 2 / (
                cum_prob[i] * (1 - cum_prob[i])
            )

    # Find threshold that maximizes variance
    threshold = np.argmax(var_between) if var_between.max() > 0 else 128

    # Apply threshold
    return blurred.point(lambda x: 255 if x > threshold else 0)


class CheckButtonGroup:
    def __init__(self, options, on_activate=None, container=None):
        self.buttons = {}

        first_button = None
        for mode, label in options:
            btn = Gtk.CheckButton(label=label)
            if first_button:
                btn.set_group(first_button)
            else:
                first_button = btn
            self.buttons[mode] = btn

            btn.connect("toggled", on_activate)

            if container is not None:
                container.append(btn)

    def set_active(self, mode):
        if mode in self.buttons:
            self.buttons[mode].set_active(True)

    def get_active(self):
        for mode, btn in self.buttons.items():
            if btn.get_active():
                return mode
        return None


class CustomDialog:
    def __init__(self, parent, title):
        self.parent = parent

        self.window = Gtk.Window()
        self.window.set_title(title)
        self.window.set_transient_for(parent)
        self.window.set_resizable(True)

    def run(self, content_box, on_confirm=None, on_cancel=None):
        self.on_confirm = on_confirm
        self.on_cancel = on_cancel

        self.window.set_child(content_box)

        # Add key controller for global shortcuts
        key_controller = Gtk.EventControllerKey.new()

        def on_key(ctrl, keyval, keycode, state):
            if keyval == Gdk.KEY_Escape:
                self.cancel()
            elif keyval == Gdk.KEY_Return:
                self.confirm()

        key_controller.connect("key-pressed", on_key)
        self.window.add_controller(key_controller)

        # Connect activate signals to all entries
        self._connect_entry_activates(content_box)

        self.show()

    def _connect_entry_activates(self, widget):
        if isinstance(widget, Gtk.Entry):
            widget.connect("activate", lambda entry: self.confirm())
        elif hasattr(widget, "get_first_child"):
            child = widget.get_first_child()
            while child:
                self._connect_entry_activates(child)
                child = child.get_next_sibling()

    def show(self):
        self.window.show()

    def confirm(self):
        if self.on_confirm:
            self.on_confirm()
        self.close()

    def cancel(self):
        if self.on_cancel:
            self.on_cancel()
        self.close()

    def close(self):
        def close_window():
            if self.window:
                self.window.close()
                self.window = None

        GLib.idle_add(close_window)


def get_temp_dir():
    return Path(os.environ.get("TMPDIR") or tempfile.gettempdir())


def get_xdg_config_home():
    return Path(os.environ.get("XDG_CONFIG_HOME") or Path.home() / ".config")


def get_config_path(app_name):
    config_home = get_xdg_config_home()
    app_config_dir = config_home / app_name
    app_config_dir.mkdir(parents=True, exist_ok=True)
    return app_config_dir / "config.json"


def get_installed_languages():
    try:
        result = subprocess.run(
            ["tesseract", "--list-langs"], capture_output=True, text=True, check=True
        )
        lines = result.stdout.strip().splitlines()
        langs = [line.strip() for line in lines[1:] if line.strip()]
        return [lang for lang in langs if lang.lower() != "osd"]
    except (subprocess.CalledProcessError, FileNotFoundError, IndexError):
        return [""]


def update_language_presets(old_languages, new_languages, presets):
    """Update presets to reflect newly installed or removed tesseract-ocr-<lang> packages"""
    old_lang_set = set(old_languages)
    new_lang_set = set(new_languages)

    # split multi-language presets
    preset_lang_sets = [set(p.split("+")) for p in presets]

    # remove presets with languages no longer in new_languages
    # i.e. tesseract-ocr-<lang> package(s) have been removed
    valid_presets = []
    for lang_set in preset_lang_sets:
        if lang_set.issubset(new_lang_set):
            valid_presets.append(lang_set)

    # find newly added languages
    # i.e. tesseract-ocr-<lang> package(s) have been installed
    added = new_lang_set - old_lang_set

    # add new languages not mentioned anywhere yet
    all_valid_langs = set()
    for lang_set in valid_presets:
        all_valid_langs.update(lang_set)

    for lang in added:
        if lang not in all_valid_langs:
            valid_presets.append({lang})

    return ["+".join(sorted(lang_set)) for lang_set in valid_presets]


class Config:
    def __init__(self, app, config_file):
        self.app = app
        self.config_file = Path(config_file)
        self.data = {}
        self.save_delay = 5.0  # seconds

    def maybe_save(self):
        def save_with_delay():
            self.save()
            self.save_timer = None

        if not self.save_timer:
            self.save_timer = self.app.after(self.save_delay, save_with_delay)

    def set(self, key, value):
        self.data[key] = value
        self.save()

    def load(self):
        app = self.app

        if app.args.verbose:
            print(f"loading {self.config_file}")

        data = {}

        try:
            if self.config_file.exists():
                with open(self.config_file, "r") as f:
                    data = json.load(f)
        except Exception as e:
            print(f"Failed to load config: {e}", file=sys.stderr)

        app.languages = data.get("languages", app.languages)
        app.language_presets = data.get("language_presets", app.language_presets)
        app.current_lang_index = data.get("current_lang_index", app.current_lang_index)
        # app.image_scale = data.get("image_scale", app.image_scale)
        app.grayscale_enabled = data.get("grayscale_enabled", app.grayscale_enabled)
        app.invert_enabled = data.get("invert_enabled", app.invert_enabled)
        app.background_equalization_enabled = data.get(
            "background_equalization_enabled", app.background_equalization_enabled
        )
        app.background_equalization_radius = data.get(
            "background_equalization_radius", app.background_equalization_radius
        )
        app.contrast_mode = data.get("contrast_mode", app.contrast_mode)
        # app.lower_threshold = data.get("lower_threshold", app.lower_threshold)
        # app.upper_threshold = data.get("upper_threshold", app.upper_threshold)
        app.binarization_mode = data.get("binarization_mode", app.binarization_mode)
        # app.binarization_threshold = data.get("binarization_threshold", app.binarization_threshold)
        app.join_result_lines = data.get("join_result_lines", app.join_result_lines)

    def save(self):
        app = self.app

        data = {
            "languages": app.languages,
            "language_presets": app.language_presets,
            "current_lang_index": app.current_lang_index,
            "image_scale": app.image_scale,
            "grayscale_enabled": app.grayscale_enabled,
            "invert_enabled": app.invert_enabled,
            "background_equalization_enabled": app.background_equalization_enabled,
            "background_equalization_radius": app.background_equalization_radius,
            "contrast_mode": app.contrast_mode,
            "lower_threshold": app.lower_threshold,
            "upper_threshold": app.upper_threshold,
            "binarization_mode": app.binarization_mode,
            "binarization_threshold": app.binarization_threshold,
            "join_result_lines": app.join_result_lines,
        }

        with open(self.config_file, "w") as f:
            json.dump(data, f, indent=2)


class App(Gtk.Application):
    def __init__(self):
        self.app_name = "screen-ocr"
        self.app_title = "Screen OCR"

        os.environ["GIO_NO_DBUS"] = "1"

        super().__init__(
            flags=Gio.ApplicationFlags.NON_UNIQUE,
        )

        self.start_x = self.start_y = 0
        self.end_x = self.end_y = 0
        self.rect_id = None
        self.screenshot_photo = None
        self.screenshot = None
        self.cropped_image = None
        self.selection_window = None
        self.sidebar = None
        self.sidebar_visible = False
        self.sidebar_timer = None
        self.sidebar_width = 200
        self.selection = None
        self.results_popover = None
        self.text = ""
        self.dragging = False
        self.notice_popup = None
        self.notice_timer = None
        self.is_dragging = False
        self.is_dragging_slider = False
        self._debounce_timer = None

    def run(self):
        self.display_server = self.detect_display_server()
        self.args = self.parse_command_line()

        self.image_scale = 1.0
        self.grayscale_enabled = True
        self.invert_enabled = False
        self.background_equalization_enabled = True
        self.background_equalization_radius = 20.0
        self.contrast_mode = "auto"
        self.lower_threshold = 0
        self.upper_threshold = 255
        self.binarization_threshold = 128  # 0..255
        self.binarization_mode = "off"
        self.join_result_lines = False

        # default language presets
        languages = get_installed_languages()
        self.languages = languages
        self.language_presets = languages[:]
        self.last_language_presets = []
        # add multi-language example
        if len(languages) >= 2:
            self.language_presets.append(languages[0] + "+" + languages[1])
        self.current_lang_index = 0

        temp_dir = get_temp_dir()

        self.config_fn = get_config_path(self.app_name)

        self.screen_fn = temp_dir / "screen-ocr-full.png"

        self.cropped_fn = temp_dir / "screen-ocr-cropped.png"

        self.output_base_fn = temp_dir / "screen-ocr-output"
        self.output_fn = self.output_base_fn.with_suffix(".txt")

        # load config
        self.config = Config(self, os.path.expanduser(self.config_fn))
        self.config.load()

        # update languages from newly installed/removed tesseract-oct-<lang> packages
        self.language_presets = update_language_presets(
            self.languages, languages, self.language_presets
        )
        self.languages = languages

        # Run main loop
        super().run()

    def do_activate(self):
        # Create main window
        self.create_window()
        self.update_ui()

        # capture full screen screenshot
        self.save_screenshot(self.screen_fn)
        self.screenshot = Image.open(self.screen_fn)

        GLib.idle_add(
            lambda: self.show_temp_notice(
                "Hold left button to draw a selection. Right click to quit.", 6000
            )
        )

    def detect_display_server(self) -> DisplayServer:
        display = os.environ.get("DISPLAY")
        wayland_display = os.environ.get("WAYLAND_DISPLAY")

        if wayland_display and not display:
            return DisplayServer.WAYLAND
        elif display and not wayland_display:
            return DisplayServer.X11
        elif display and wayland_display:
            return DisplayServer.XWAYLAND
        else:
            return DisplayServer.UNKNOWN

    def save_screenshot(self, screen_fn: Path):
        self.run_display_server_command(
            ["import", "-window", "root", str(screen_fn)],
            ["grim", "-t", "png", "-o", "1", str(screen_fn)],
        )

    def run_display_server_command(
        self, x11_cmd, wayland_cmd, input_text: str | None = None
    ):
        if self.display_server == DisplayServer.X11:
            cmds = [x11_cmd]
        elif self.display_server == DisplayServer.WAYLAND:
            cmds = [wayland_cmd]
        else:
            cmds = [wayland_cmd, x11_cmd]  # XWAYLAND, UNKNOWN

        for cmd in cmds:
            try:
                self.run_command(cmd, input_text)
                return  # Success â€” exit early
            except (FileNotFoundError, subprocess.CalledProcessError):
                continue  # Try next command

        print(
            "run_display_server_command ERROR: All commands failed - ", file=sys.stderr
        )

    def run_command(self, cmd, input_text: str | None = None):
        if self.args.verbose:
            print("run_command:", " ".join(cmd))

        try:
            if input_text is None:
                subprocess.run(cmd, check=True)
            else:
                subprocess.run(cmd, input=input_text, text=True, check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as ex:
            if self.args.verbose:
                print(f"run_command: {" ".join(cmd)}: {ex}", file=sys.stderr)
            raise ex

    @staticmethod
    def parse_command_line():
        parser = argparse.ArgumentParser(description="Screen OCR tool")
        parser.add_argument(
            "-v", "--verbose", action="store_true", help="Enable verbose output"
        )
        return parser.parse_args()

    def create_window(self):
        # Create main window
        self.window = Gtk.ApplicationWindow(application=self)
        self.window.set_default_size(800, 600)
        self.window.set_title(self.app_title)

        # Fullscreen
        self.window.fullscreen()

        # Main layout
        main_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        self.window.set_child(main_box)

        # Canvas area
        self.canvas = Gtk.DrawingArea()
        self.canvas.set_vexpand(True)
        self.canvas.set_hexpand(True)
        self.canvas.set_draw_func(self.on_draw)

        # Event controllers
        click_controller = Gtk.GestureClick()
        click_controller.connect("pressed", self.on_click_pressed)
        click_controller.connect("released", self.on_click_released)
        self.canvas.add_controller(click_controller)

        motion_controller = Gtk.EventControllerMotion()
        motion_controller.connect("motion", self.on_mouse_move)
        self.canvas.add_controller(motion_controller)

        # Keyboard controller
        key_controller = Gtk.EventControllerKey()
        key_controller.connect("key-pressed", self.on_key_pressed)
        self.canvas.add_controller(key_controller)

        # Right click controller
        right_click = Gtk.GestureClick()
        right_click.set_button(3)  # Right click
        right_click.connect("pressed", self.on_right_click)
        self.canvas.add_controller(right_click)

        # Sidebar
        sidebar = self.create_sidebar()
        sidebar.set_size_request(self.sidebar_width, -1)

        revealer = Gtk.Revealer()
        revealer.set_hexpand(False)
        revealer.set_vexpand(False)
        revealer.set_valign(Gtk.Align.START)
        revealer.set_halign(Gtk.Align.END)
        revealer.set_opacity(1.0)
        revealer.add_css_class("background")
        revealer.set_child(sidebar)
        revealer.set_transition_type(Gtk.RevealerTransitionType.SLIDE_RIGHT)
        revealer.set_reveal_child(False)  # hidden by default

        self.sidebar = revealer

        overlay = Gtk.Overlay()
        overlay.set_child(self.canvas)
        overlay.add_overlay(self.sidebar)
        main_box.append(overlay)

        # Show window
        self.window.present()

    def create_sidebar(self):
        sidebar = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        sidebar.set_size_request(200, -1)
        sidebar.set_margin_start(5)
        sidebar.set_margin_end(5)
        sidebar.set_margin_top(10)
        sidebar.set_margin_bottom(10)

        # Language section
        label = Gtk.Label(label="Language")
        label.add_css_class("heading")
        label.set_halign(Gtk.Align.START)
        label.set_margin_bottom(5)
        sidebar.append(label)

        lang_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        lang_box.set_margin_bottom(5)

        lang_combo = Gtk.DropDown.new()
        lang_combo.connect(
            "notify::selected", lambda dropdown, pspec: self.on_image_param_changed()
        )
        self.lang_drop_down = lang_combo

        edit_button = Gtk.Button(label="Edit")
        edit_button.connect("clicked", self.edit_languages)

        lang_box.append(self.lang_drop_down)
        lang_box.append(edit_button)
        sidebar.append(lang_box)

        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.set_margin_top(5)
        separator.set_margin_bottom(5)
        sidebar.append(separator)

        # Preprocessing section
        label = Gtk.Label(label="Preprocessing")
        label.add_css_class("heading")
        label.set_halign(Gtk.Align.START)
        label.set_margin_bottom(5)
        sidebar.append(label)

        # Image scale
        self.image_scale_label = Gtk.Label()
        self.image_scale_label.set_halign(Gtk.Align.START)
        self.image_scale_label.set_margin_bottom(2)
        sidebar.append(self.image_scale_label)

        adjustment = Gtk.Adjustment.new(
            value=2.0,
            lower=math.log2(0.125),
            upper=math.log2(8.0),
            step_increment=0.1,
            page_increment=0.1,
            page_size=0,
        )
        scale = Gtk.Scale.new(Gtk.Orientation.HORIZONTAL)
        scale.set_adjustment(adjustment)

        scale.connect(
            "value-changed",
            lambda slider: self.on_image_param_changed_debounced(),
        )

        sidebar.append(scale)
        self.image_scale_slider = scale

        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.set_margin_top(5)
        separator.set_margin_bottom(5)
        sidebar.append(separator)

        # Grayscale toggle
        self.grayscale_toggle = Gtk.CheckButton(label="Grayscale")
        self.grayscale_toggle.connect("toggled", self.on_image_param_changed)
        sidebar.append(self.grayscale_toggle)

        # Invert toggle
        self.invert_toggle = Gtk.CheckButton(label="Invert")
        self.invert_toggle.connect("toggled", self.on_image_param_changed)
        sidebar.append(self.invert_toggle)

        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.set_margin_top(5)
        separator.set_margin_bottom(5)
        sidebar.append(separator)

        # Background equalization toggle
        self.bg_equal_toggle = Gtk.CheckButton(label="Equalize Background")
        self.bg_equal_toggle.connect("toggled", self.on_image_param_changed)
        sidebar.append(self.bg_equal_toggle)

        # Background equalization radius
        self.bge_radius_label = Gtk.Label()
        self.bge_radius_label.set_halign(Gtk.Align.START)
        self.bge_radius_label.set_margin_bottom(2)
        sidebar.append(self.bge_radius_label)

        adjustment = Gtk.Adjustment.new(
            value=0,
            lower=0,
            upper=256,
            step_increment=1.0,
            page_increment=1.0,
            page_size=0,
        )
        scale = Gtk.Scale.new(Gtk.Orientation.HORIZONTAL)
        scale.set_adjustment(adjustment)
        scale.connect(
            "value-changed", lambda slider: self.on_image_param_changed_debounced()
        )
        self.bge_radius_slider = scale
        sidebar.append(scale)

        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.set_margin_top(5)
        separator.set_margin_bottom(5)
        sidebar.append(separator)

        # Levels section
        label = Gtk.Label(label="Levels")
        label.add_css_class("heading")
        label.set_halign(Gtk.Align.START)
        label.set_margin_bottom(5)
        sidebar.append(label)

        contrast_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        self.contrast_button_group = CheckButtonGroup(
            [
                ("auto", "Auto Contrast"),
                ("equalize", "Equalize"),
                ("manual", "Manual"),
            ],
            on_activate=self.on_image_param_changed,
            container=contrast_box,
        )

        sidebar.append(contrast_box)

        # Manual levels sliders
        self.lower_level_frame = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.upper_level_frame = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        lower_label = Gtk.Label(label="Lower:")
        lower_label.set_halign(Gtk.Align.START)
        self.lower_slider = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 0, 255, 1
        )
        self.lower_slider.connect(
            "value-changed", lambda slider: self.on_image_param_changed_debounced()
        )

        upper_label = Gtk.Label(label="Upper:")
        upper_label.set_halign(Gtk.Align.START)
        self.upper_slider = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 0, 255, 1
        )
        self.upper_slider.connect(
            "value-changed", lambda slider: self.on_image_param_changed_debounced()
        )

        self.lower_level_frame.append(lower_label)
        self.lower_level_frame.append(self.lower_slider)
        self.upper_level_frame.append(upper_label)
        self.upper_level_frame.append(self.upper_slider)

        sidebar.append(self.lower_level_frame)
        sidebar.append(self.upper_level_frame)

        # Separator
        separator = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        separator.set_margin_top(5)
        separator.set_margin_bottom(5)
        sidebar.append(separator)

        # Binarization section
        label = Gtk.Label(label="Binarization")
        label.add_css_class("heading")
        label.set_halign(Gtk.Align.START)
        label.set_margin_bottom(5)
        sidebar.append(label)

        binarization_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        self.binarization_button_group = CheckButtonGroup(
            [
                ("off", "Off"),
                ("otsu", "Otsu"),
                ("otsu2", "Otsu Improved"),
                ("threshold", "Threshold"),
            ],
            on_activate=self.on_image_param_changed,
            container=binarization_box,
        )

        sidebar.append(binarization_box)

        # Threshold slider
        self.threshold_frame = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        threshold_label = Gtk.Label(label="Threshold:")
        threshold_label.set_halign(Gtk.Align.START)
        self.bin_threshold_slider = Gtk.Scale.new_with_range(
            Gtk.Orientation.HORIZONTAL, 0, 255, 1
        )
        self.bin_threshold_slider.connect(
            "value-changed", lambda slider: self.on_image_param_changed_debounced()
        )

        self.threshold_frame.append(threshold_label)
        self.threshold_frame.append(self.bin_threshold_slider)

        sidebar.append(self.threshold_frame)

        return sidebar

    def on_image_param_changed_debounced(self):
        self.on_image_param_changed(False)

        if self._debounce_timer:
            GLib.source_remove(self._debounce_timer)

        def on_timer():
            self._debounce_timer = None
            self.on_image_param_changed(True)
            return GLib.SOURCE_REMOVE

        self._debounce_timer = GLib.timeout_add(250, on_timer)

    def on_image_param_changed(self, process=True):
        if self._in_update_sidebar:
            return

        selected = self.lang_drop_down.get_selected()
        if selected >= 0:
            self.current_lang_index = selected

        val = self.image_scale_slider.get_value()
        if abs(val) < 0.1:  # close to scale 1.0?
            val = round(val)  # snap to it
        self.image_scale = math.pow(2, val)

        self.grayscale_enabled = self.grayscale_toggle.get_active()
        self.invert_enabled = self.invert_toggle.get_active()
        self.background_equalization_enabled = self.bg_equal_toggle.get_active()
        self.background_equalization_radius = round(self.bge_radius_slider.get_value())
        self.contrast_mode = self.contrast_button_group.get_active()
        self.lower_threshold = self.lower_slider.get_value()
        self.upper_threshold = self.upper_slider.get_value()
        self.binarization_threshold = self.bin_threshold_slider.get_value()
        self.binarization_mode = self.binarization_button_group.get_active()

        self.update_ui()
        if process:
            self.process_selection()

    def update_sidebar(self):
        self._in_update_sidebar = True

        if self.last_language_presets != self.language_presets:
            store = Gio.ListStore.new(Gtk.StringObject)
            for lang in self.language_presets:
                store.append(Gtk.StringObject.new(lang))

            self.lang_drop_down.set_model(store)
            self.last_language_presets = self.language_presets[:]

        if self.current_lang_index < len(self.language_presets):
            if self.lang_drop_down.get_selected() != self.current_lang_index:
                self.lang_drop_down.set_selected(self.current_lang_index)

        self.image_scale_slider.set_value(math.log2(self.image_scale))
        self.grayscale_toggle.set_active(self.grayscale_enabled)
        self.invert_toggle.set_active(self.invert_enabled)
        self.bg_equal_toggle.set_active(self.background_equalization_enabled)
        self.bge_radius_slider.set_value(self.background_equalization_radius)
        self.contrast_button_group.set_active(self.contrast_mode)
        self.lower_slider.set_value(self.lower_threshold)
        self.upper_slider.set_value(self.upper_threshold)
        self.bin_threshold_slider.set_value(self.binarization_threshold)
        self.binarization_button_group.set_active(self.binarization_mode)

        manual_levels = self.contrast_mode == "manual"
        self.lower_level_frame.set_sensitive(manual_levels)
        self.upper_level_frame.set_sensitive(manual_levels)

        self.threshold_frame.set_sensitive(self.binarization_mode == "threshold")

        self.image_scale_label.set_text(f"Scale: {self.image_scale:.3g}")
        self.bge_radius_label.set_text(f"Radius: {self.background_equalization_radius}")

        self._in_update_sidebar = False

    def update_ui(self):
        self.update_sidebar()

        if self.selection:
            # crop to selection
            img = self.screenshot.crop(self.selection)

            if self.image_scale != 1.0:
                max_width = int(img.width * self.image_scale)
                max_height = int(img.height * self.image_scale)

                if self.image_scale > 1.0:  # Scale up
                    img = img.resize((max_width, max_height), Image.Resampling.BICUBIC)
                else:  # Scale down
                    img = img.resize((max_width, max_height), Image.Resampling.LANCZOS)

            if self.grayscale_enabled:
                img = img.convert("L")

            if self.invert_enabled:
                img = ImageOps.invert(img)

            if self.background_equalization_enabled:
                img = equalize_background(img, self.background_equalization_radius)

            match self.contrast_mode:
                case "auto":
                    img = ImageOps.autocontrast(img)
                case "equalize":
                    img = ImageOps.equalize(img)
                case "manual":
                    # Apply levels adjustment
                    lower = self.lower_threshold
                    upper = self.upper_threshold
                    img = img.point(
                        lambda x: (
                            0
                            if x < lower or lower >= upper
                            else (
                                255
                                if x > upper
                                else int((x - lower) * 255.0 / (upper - lower))
                            )
                        )
                    )

            match self.binarization_mode:
                case "off":
                    pass
                case "threshold":
                    # Binarize using PIL's threshold
                    img = img.convert("L").point(
                        lambda x: 0 if x <= self.binarization_threshold else 255
                    )
                case "otsu":
                    img = otsu_binarize(img)
                case "otsu2":
                    img = otsu_binarize_improved(img)

            self.cropped_image = img

    def redraw(self):
        self.canvas.queue_draw()

    def on_draw(self, area, ctx, width, height):
        # Clear background
        ctx.set_source_rgb(0, 0, 0)
        ctx.rectangle(0, 0, width, height)
        ctx.fill()

        # Draw screenshot
        if self.screenshot:
            self.screenshot_pixbuf = self.pil_to_pixbuf(self.screenshot)
            Gdk.cairo_set_source_pixbuf(ctx, self.screenshot_pixbuf, 0, 0)
            ctx.paint()

        if self.selection:
            x0, y0, x1, y1 = self.selection

            # Draw cropped image
            if not self.is_dragging and self.cropped_image:
                self.cropped_image_pixbuf = self.pil_to_pixbuf(self.cropped_image)
                Gdk.cairo_set_source_pixbuf(ctx, self.cropped_image_pixbuf, x0, y0)
                ctx.paint()

            # Draw selection rectangle
            ctx.set_source_rgb(1, 0, 0)  # Red
            ctx.set_line_width(2)
            ctx.set_dash([5, 5])  # Dashed line
            ctx.rectangle(x0, y0, x1 - x0, y1 - y0)
            ctx.stroke()
            ctx.set_dash([])  # Reset dash

        # Draw green frame
        w = 8
        wh = w * 0.5
        start_x = start_y = wh
        end_x = width - wh
        end_y = height - wh

        ctx.set_source_rgba(0, 1, 0, 0.3)
        ctx.set_line_width(w)
        ctx.rectangle(start_x, start_y, end_x - start_x, end_y - start_y)
        ctx.stroke()
        ctx.set_dash([])

    def pil_to_pixbuf(self, pil_image):
        width, height = pil_image.size

        # Ensure RGB or RGBA
        if pil_image.mode != "RGB":
            pil_image = pil_image.convert("RGB")

        has_alpha = pil_image.mode == "RGBA"
        bytes_per_pixel = 4 if has_alpha else 3
        stride = width * bytes_per_pixel

        # Get raw bytes
        pixels = pil_image.tobytes()
        buffer = GLib.Bytes.new(pixels)

        pixbuf = GdkPixbuf.Pixbuf.new_from_bytes(
            buffer,
            GdkPixbuf.Colorspace.RGB,
            has_alpha,
            8,  # bits per sample
            width,
            height,
            stride,
        )

        return pixbuf

    def on_click_pressed(self, gesture, n_press, x, y):
        self.start_selection((x, y))

    def on_click_released(self, gesture, n_press, x, y):
        self.end_selection((x, y))

    def on_mouse_move(self, controller, x, y):
        if self.is_dragging:
            self.update_selection((x, y))
            self.redraw()

        screen_width = self.window.get_width()
        edge_distance = self.sidebar_width if self.sidebar_visible else 20

        # Is the cursor near the right edge?
        if x > screen_width - edge_distance:
            self.show_sidebar()
            self.stop_sidebar_timer()
        else:

            def on_timer():
                self.sidebar_timer = None
                self.hide_sidebar()
                return GLib.SOURCE_REMOVE

            if not self.sidebar_timer:
                self.sidebar_timer = GLib.timeout_add(500, on_timer)

    def stop_sidebar_timer(self):
        if self.sidebar_timer:
            GLib.source_remove(self.sidebar_timer)
            self.sidebar_timer = None

    def show_sidebar(self):
        if not self.sidebar_visible:
            self.sidebar.set_reveal_child(True)
            self.sidebar_visible = True

    def hide_sidebar(self):
        if self.sidebar_visible:
            self.sidebar.set_reveal_child(False)
            self.sidebar_visible = False
            self.stop_sidebar_timer()

    def on_key_pressed(self, controller, keyval, keycode, state):
        if keyval == Gdk.KEY_Escape:
            self.quit_selection()

    def on_right_click(self, gesture, n_press, x, y):
        self.copy_and_exit()

    def start_selection(self, pos):
        self.hide_temp_notice()
        self.start_x, self.start_y = pos
        self.is_dragging = True

    def update_selection(self, pos):
        self.end_x, self.end_y = pos
        self.selection = (
            min(self.start_x, self.end_x),
            min(self.start_y, self.end_y),
            max(self.start_x, self.end_x),
            max(self.start_y, self.end_y),
        )

    def end_selection(self, pos):
        if self.selection:
            self.update_ui()
            self.process_selection()
        self.is_dragging = False

    def process_selection(self):
        cropped = self.cropped_image
        if not cropped:
            return

        # Tesseract recommends adding a white border
        border = 10
        bordered = Image.new(
            "RGB",
            (cropped.width + 2 * border, cropped.height + 2 * border),
            color="white",
        )
        bordered.paste(cropped, (border, border))

        # Save cropped image
        bordered.save(self.cropped_fn)

        # Run OCR
        cmd = [
            "tesseract",
            str(self.cropped_fn),
            str(self.output_base_fn),
            "--psm",
            "6",
            "--dpi",
            "72",
            "-c",
            "thresholding_method=1",
            "-c",
            "thresholding_score_fraction=0.1",
            "-l",
            self.language_presets[self.current_lang_index],
        ]

        if self.args.verbose:
            print(" ".join(cmd))

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
        )

        if result.returncode == 0:
            # Read output
            with open(self.output_fn, "r") as f:
                text = f.read().strip()
            self.text = text

            self.show_result()
        else:
            print("OCR failed")

    def show_result(self):
        if self.results_popover:
            self.results_popover.popdown()
            self.results_popover = None

        popover = Gtk.Popover()
        popover.set_has_arrow(True)
        popover.set_autohide(False)
        popover.set_parent(self.canvas)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        k = 10
        main_box.set_margin_start(k)
        main_box.set_margin_end(k)
        main_box.set_margin_top(k)
        main_box.set_margin_bottom(k)
        popover.set_child(main_box)

        text_view = Gtk.TextView()
        text_view.set_vexpand(True)
        text_view.set_hexpand(True)
        self.results_text_widget = text_view

        scrolled = Gtk.ScrolledWindow()
        scrolled.set_child(text_view)
        scrolled.set_vexpand(True)
        scrolled.set_min_content_width(500)
        scrolled.set_min_content_height(200)

        frame = Gtk.Frame()
        frame.set_child(scrolled)
        main_box.append(frame)

        controls_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        controls_box.set_spacing(6)
        buttons_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        buttons_box.set_spacing(6)

        join_check = Gtk.CheckButton(label="Join lines")
        join_check.set_active(self.join_result_lines)
        join_check.connect("toggled", self.on_join_lines_changed)
        controls_box.append(join_check)

        spacer = Gtk.Box()
        spacer.set_hexpand(True)
        controls_box.append(spacer)

        cancel_button = Gtk.Button(label="Cancel")
        cancel_button.connect("clicked", lambda w: self.exit())
        buttons_box.append(cancel_button)

        copy_exit_button = Gtk.Button(label="Copy & Exit")
        copy_exit_button.connect("clicked", lambda w: self.copy_and_exit())
        buttons_box.append(copy_exit_button)

        controls_box.append(buttons_box)

        main_box.append(controls_box)

        if self.selection:
            x0, y0, x1, y1 = self.selection
            rect = Gdk.Rectangle()
            rect.x = x0
            rect.y = y0
            rect.width = x1 - x0
            rect.height = y1 - y0
            popover.set_pointing_to(rect)
            popover.set_position(Gtk.PositionType.BOTTOM)

        self.results_popover = popover
        self.update_results_text_widget()
        popover.present()
        popover.popup()

    def on_join_lines_changed(self, toggle):
        self.join_result_lines = toggle.get_active()
        self.update_results_text_widget()

    def update_results_text_widget(self):
        text = self.get_result_text()
        self.results_text_widget.get_buffer().set_text(text)

    def get_result_text(self):
        text = self.text

        if self.join_result_lines:
            text = " ".join(line.strip() for line in text.splitlines() if line)
        return text

    def show_temp_notice(self, text, duration=3000):
        if self.notice_popup:
            self.hide_temp_notice()

        label = Gtk.Label(label=text)
        label.set_margin_top(10)
        label.set_margin_bottom(10)
        label.set_margin_start(10)
        label.set_margin_end(10)

        popup = Gtk.Popover()
        popup.set_child(label)

        w, h = self.canvas.get_width(), self.canvas.get_height()
        bottom_margin = int(h * 0.05)
        rect = Gdk.Rectangle()
        rect.x = w / 2
        rect.y = h - bottom_margin
        rect.width = 0
        rect.height = 0

        popup.set_pointing_to(rect)
        popup.set_has_arrow(False)
        popup.set_autohide(False)
        popup.set_position(Gtk.PositionType.TOP)
        popup.set_parent(self.canvas)

        popup.popup()
        self.notice_popup = popup

        GLib.timeout_add(duration, self.hide_temp_notice)

    def hide_temp_notice(self):
        if self.notice_popup:
            self.notice_popup.popdown()
            self.notice_popup = None
            self.notice_timer = None

    def quit_selection(self, widget=None):
        self.copy_and_exit()

    def copy_and_exit(self):
        text = self.get_result_text()
        print(text)

        # Copy to clipboard
        clipboard = self.window.get_clipboard()
        if clipboard:
            content = Gdk.ContentProvider()
            content.data = text
            clipboard.set_content(content)

        self.exit()

    def exit(self):
        self.config.save()

        # Clean up temp files
        if self.screen_fn and os.path.exists(self.screen_fn):
            os.unlink(self.screen_fn)
        if self.cropped_fn and os.path.exists(self.cropped_fn):
            os.unlink(self.cropped_fn)
        if self.output_fn and os.path.exists(self.output_fn):
            os.unlink(self.output_fn)

        # Quit application
        self.quit()

    def edit_languages(self, widget=None):
        initial_text = "\n".join(self.language_presets)
        help_text = (
            "Edit the list of languages below, one per line.\n"
            "You can combine languages with '+' (e.g., 'eng+jpn').\n"
            "Available languages: " + ", ".join(self.languages)
        )

        # Build content box
        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        content_box.set_margin_start(10)
        content_box.set_margin_end(10)
        content_box.set_margin_top(10)
        content_box.set_margin_bottom(10)

        # Help label
        label = Gtk.Label()
        label.set_markup(f"<b>Help:</b>\n{help_text}")
        label.set_xalign(0)
        content_box.append(label)

        # Text buffer/view
        text_buffer = Gtk.TextBuffer()
        text_buffer.set_text(initial_text)
        text_view = Gtk.TextView(buffer=text_buffer)
        text_view.set_size_request(300, 200)
        content_box.append(text_view)

        # Create action buttons
        button_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        button_box.set_halign(Gtk.Align.END)
        button_box.set_margin_top(10)
        content_box.append(button_box)

        cancel_button = Gtk.Button(label="Cancel")
        cancel_button.connect("clicked", lambda btn: dialog.cancel())
        button_box.append(cancel_button)

        ok_button = Gtk.Button(label="OK")
        ok_button.connect(
            "clicked",
            lambda btn: dialog.confirm(),
        )
        button_box.append(ok_button)

        # Confirm/cancel handlers
        def on_confirm():
            start, end = text_buffer.get_bounds()
            text = text_buffer.get_text(start, end, False)

            presets = [line.strip() for line in text.splitlines() if line.strip()]
            self.language_presets = presets
            self.update_sidebar()

        # Create dialog
        dialog = CustomDialog(parent=self.window, title="Edit Languages")
        dialog.run(content_box=content_box, on_confirm=on_confirm)


if __name__ == "__main__":
    if not os.path.exists("/usr/bin/import"):
        print("Error: ImageMagick 'import' command not found")
        sys.exit(1)
    if not os.path.exists("/usr/bin/tesseract"):
        print("Error: Tesseract OCR not found")
        sys.exit(1)
    app = App()
    app.run()
